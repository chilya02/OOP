# Инструкция по оформлению кода
## Заголовки
* Используем зашиту
``` C++
#ifndef FOO_BAR_BAZ_H_
#define FOO_BAR_BAZ_H_

...

#endif  // FOO_BAR_BAZ_H_

```
* Избегаем объявления в `cpp` файлах
* Порядок включения заголовков:
1. Связаныный заголовок
2. Системные заголовки `C`
3. Заголовки стандартной библиотеки `C++`
4. Заголовки других библиотек
5. Заголовки проекта

> [!NOTE]
> Каждую группу следует отделять пустой строкой

## Области видимости 
### Пространства имен
* Не используем конструкцию `using`
* Пишем комментарий в конце многострочного объявления пространства имен
* Функции и переменные, которые не исользуются извне, можно поместить в безыменное пространство  или объявить `static`, в обоих случаях в `.h` файлах они не объявляются

```C++
namespace {
...
}  // namespace
```
##### Пример:

```C++
// In the .h file
namespace mynamespace {

// All declarations are within the namespace scope.
// Notice the lack of indentation.
class MyClass {
 public:
  ...
  void Foo();
};

}  // namespace mynamespace
```
### Переменные
* Помещаем внутрь области использования
* Инициализируем при создании
* Для `for`, `while`, `if` объявляем в операторе
* Следим за "временем жизни" каждой переменной

### Классы
* Конструкторы не должны вызывать виртуальных функций 
* Операторы преобразования типов или конструкторы с одним должны быть помечечны `explicit` а описании класса. 
* Явно определяем копируемость и перемещаемость объектов в конструкторах и опреаторах
* Поля должны быть `private`, если это не константы
* Методы должны быть `protected` только когда их использует наследующий класс
* Не используем свои литералы при перегрузке операторов  
* Порядок объявления элементов класса:
1. Типы и псевдонимы (`typedef`, `using`, вложенные структуры и классы)
2. Для структур - статические элементы, не являющиеся данными
3. Статические константы
4. Фабричные функции
5. Конструкторы и операторы присваивания
6. Деструктор
7. Статические и нестатические методы
8. Поля (статические и нестатические)

### Функции 
* Перегрузка допустима при отсутствии семантических различий (отличается тип аргументов или количество)
* Не используем аргументы по умолчанию в виртуальных функциях и когда они дают разное значение


